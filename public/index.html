<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Context Lens</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; background: #0a0a0a; color: #e5e5e5; font-size: 13px; }
.app { display: grid; grid-template-columns: 280px 1fr; grid-template-rows: 48px 1fr; height: 100vh; }

/* Header */
.header { grid-column: 1 / -1; background: #141414; border-bottom: 1px solid #262626; display: flex; align-items: center; padding: 0 16px; gap: 12px; }
.header h1 { font-size: 15px; font-weight: 600; }
.header-right { margin-left: auto; display: flex; gap: 16px; align-items: center; font-size: 12px; }
.header select, .header button { background: #1e1e1e; border: 1px solid #333; color: #e5e5e5; padding: 4px 12px; border-radius: 4px; font-size: 12px; cursor: pointer; }
.header button:hover { border-color: #3b82f6; color: #93c5fd; }

/* Sidebar */
.sidebar { background: #111; border-right: 1px solid #262626; overflow-y: auto; display: flex; flex-direction: column; }
.sidebar-section { padding: 10px 12px 4px; font-size: 10px; color: #555; text-transform: uppercase; letter-spacing: 0.08em; }
.session-item { padding: 8px 12px; cursor: pointer; border-left: 2px solid transparent; }
.session-item:hover { background: #1a1a1a; }
.session-item.active { background: #111827; border-left-color: #3b82f6; }
.session-head { display: flex; align-items: center; gap: 8px; }
.session-meta { display: flex; gap: 12px; margin-top: 4px; padding-left: 14px; font-size: 11px; color: #555; }
.badge { font-size: 9px; padding: 2px 6px; border-radius: 3px; font-weight: 700; text-transform: uppercase; }
.badge-claude { background: #451a03; color: #fb923c; }
.badge-codex { background: #052e16; color: #34d399; }
.badge-aider { background: #1e1e1e; color: #60a5fa; }
.badge-kimi { background: #1e1e1e; color: #a78bfa; }
.badge-unknown { background: #1e1e1e; color: #888; }
.dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }
.dot-live { background: #3b82f6; box-shadow: 0 0 4px #3b82f6; }
.dot-done { background: #444; }
.turn-group { margin-left: 14px; border-left: 1px solid #1e1e1e; display: none; }
.turn-group.expanded { display: block; }
.tg-item { padding: 5px 12px; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 12px; }
.tg-item:hover { background: #151515; }
.tg-item.active { background: #111827; }
.tg-num { color: #555; width: 16px; text-align: right; font-size: 11px; }
.tg-model { font-size: 9px; padding: 1px 4px; border-radius: 2px; }
.tg-desc { color: #888; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.tg-tokens { margin-left: auto; color: #444; font-size: 11px; white-space: nowrap; }
.sub-dots { display: flex; gap: 4px; padding: 2px 12px 2px 40px; font-size: 10px; color: #444; align-items: center; }
.sub-dot { width: 4px; height: 4px; border-radius: 50%; background: #a78bfa; }
.sidebar-footer { padding: 10px 12px; border-top: 1px solid #1e1e1e; margin-top: auto; font-size: 11px; color: #444; }
.sidebar-footer div { display: flex; justify-content: space-between; padding: 2px 0; }

/* Main */
.main { overflow-y: auto; padding: 16px 20px; display: flex; flex-direction: column; gap: 14px; }

/* Panel */
.panel { background: #141414; border: 1px solid #262626; border-radius: 8px; overflow: hidden; }
.panel-header { padding: 10px 16px; font-size: 11px; font-weight: 600; color: #666; text-transform: uppercase; letter-spacing: 0.06em; border-bottom: 1px solid #1e1e1e; display: flex; justify-content: space-between; align-items: center; }
.panel-body { padding: 16px; }

/* Stats row */
.stats-row { display: flex; gap: 14px; }
.stats-row .panel { flex: 1; }
.stat-card { text-align: center; padding: 4px; }
.stat-val { font-size: 26px; font-weight: 700; }
.stat-lbl { font-size: 10px; color: #555; margin-top: 2px; }
.blue { color: #3b82f6; }
.green { color: #10b981; }
.amber { color: #f59e0b; }
.white { color: #e5e5e5; }
.red { color: #ef4444; }

/* Treemap */
.treemap { display: flex; height: 90px; border-radius: 4px; overflow: hidden; gap: 2px; }
.treemap-block { display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 500; color: rgba(255,255,255,0.9); flex-direction: column; gap: 1px; cursor: default; transition: opacity 0.15s; }
.treemap-block:hover { opacity: 0.85; }
.treemap-block span { font-size: 8px; opacity: 0.7; }
.tm-system_prompt { background: #1e40af; }
.tm-tool_definitions { background: #be185d; }
.tm-tool_results { background: #065f46; }
.tm-system_injections { background: #4338ca; }
.tm-thinking { background: #7c3aed; }
.tm-assistant_text { background: #b45309; }
.tm-user_text { background: #059669; }
.tm-tool_calls { background: #9d174d; }
.tm-images { background: #374151; }
.tm-cache_markers { background: #525252; }
.tm-other { background: #404040; }
.treemap-legend { display: flex; gap: 12px; margin-top: 10px; flex-wrap: wrap; }
.treemap-legend-item { display: flex; align-items: center; gap: 4px; font-size: 10px; color: #888; }
.treemap-legend-dot { width: 10px; height: 10px; border-radius: 2px; }

/* Agent breakdown */
.agent-row { display: flex; align-items: center; gap: 8px; padding: 4px 0; font-size: 12px; }
.agent-bar-wrap { flex: 1; height: 6px; background: #1a1a1a; border-radius: 3px; overflow: hidden; }
.agent-bar { height: 100%; border-radius: 3px; }
.agent-lbl { width: 110px; color: #888; font-size: 11px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.agent-val { width: 110px; text-align: right; color: #555; font-size: 11px; white-space: nowrap; }

/* Timeline */
.timeline-chart { display: flex; align-items: flex-end; gap: 1px; height: 80px; }
.tl-bar { flex: 1; min-width: 4px; max-width: 24px; border-radius: 2px 2px 0 0; cursor: pointer; transition: opacity 0.15s; }
.tl-bar:hover { opacity: 0.8; }
.tl-bar.active { box-shadow: 0 0 0 1px #3b82f6; }
.tl-legend { display: flex; gap: 16px; margin-top: 8px; }
.tl-legend-item { display: flex; align-items: center; gap: 4px; font-size: 10px; color: #666; }
.tl-legend-dot { width: 8px; height: 8px; border-radius: 2px; }

/* Toggle */
.toggle-group { display: flex; }
.toggle-btn { font-size: 10px; padding: 3px 10px; background: #1a1a1a; border: 1px solid #262626; color: #666; cursor: pointer; }
.toggle-btn:first-child { border-radius: 4px 0 0 4px; }
.toggle-btn:last-child { border-radius: 0 4px 4px 0; }
.toggle-btn.active { background: #1e3a5f; border-color: #3b82f6; color: #93c5fd; }

/* Empty state */
.empty-main { display: flex; align-items: center; justify-content: center; height: 100%; color: #555; flex-direction: column; gap: 8px; }

/* Working dir */
.working-dir { font-size: 10px; color: #444; font-family: 'SF Mono', 'Fira Code', Consolas, monospace; margin-top: 2px; padding-left: 14px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* Model color helpers */
.model-opus { color: #fb923c; }
.model-sonnet { color: #60a5fa; }
.model-haiku { color: #a78bfa; }
.model-gpt { color: #10b981; }
.model-default { color: #888; }

/* Turn detail */
.turn-detail-header { display: flex; gap: 8px; align-items: center; margin-bottom: 12px; font-size: 12px; color: #888; }
.call-row { display: flex; align-items: center; gap: 8px; padding: 5px 8px; border-radius: 4px; font-size: 12px; margin-bottom: 2px; }
.call-row:hover { background: #1a1a1a; }
.call-row.main-call { background: #111827; border-radius: 4px; }
.call-model { font-size: 9px; padding: 1px 5px; border-radius: 2px; width: 46px; text-align: center; }
.call-desc { color: #888; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.call-desc.main { color: #e5e5e5; }
.call-tok { color: #555; font-size: 11px; width: 70px; text-align: right; }
.call-cost { color: #10b981; font-size: 11px; width: 50px; text-align: right; }

/* Message categories */
.msg-section { margin-top: 12px; border-top: 1px solid #1e1e1e; padding-top: 12px; }
.msg-section-title { font-size: 11px; color: #555; margin-bottom: 8px; display: flex; justify-content: space-between; }
.msg-category { margin-bottom: 8px; }
.msg-cat-header { display: flex; align-items: center; gap: 6px; padding: 4px 0; cursor: pointer; font-size: 12px; }
.msg-cat-header:hover { color: #fff; }
.msg-cat-dot { width: 8px; height: 8px; border-radius: 2px; flex-shrink: 0; }
.msg-cat-name { font-weight: 500; }
.msg-cat-stats { margin-left: auto; color: #444; font-size: 11px; }
.msg-cat-bar-wrap { width: 60px; height: 4px; background: #1a1a1a; border-radius: 2px; overflow: hidden; margin-left: 8px; }
.msg-cat-bar { height: 100%; border-radius: 2px; }
.msg-items { padding-left: 20px; border-left: 1px solid #1e1e1e; margin-left: 3px; display: none; }
.msg-items.expanded { display: block; }
.msg-line { display: flex; align-items: center; gap: 6px; padding: 3px 0; font-size: 11px; color: #888; border-bottom: 1px solid #0f0f0f; }
.msg-line:hover { color: #ccc; }
.msg-line-icon { color: #444; width: 14px; font-size: 10px; }
.msg-line-text { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.msg-line-tok { color: #444; font-size: 10px; white-space: nowrap; }
.msg-line-tok.large { color: #f59e0b; }

/* Context diff */
.diff-section { margin-top: 12px; border-top: 1px solid #1e1e1e; padding-top: 12px; }
.diff-header { font-size: 11px; color: #555; margin-bottom: 6px; display: flex; justify-content: space-between; }
.diff-line { font-family: 'SF Mono', 'Fira Code', Consolas, monospace; font-size: 11px; padding: 2px 8px; border-radius: 2px; margin-bottom: 1px; }
.diff-add { background: #071f0e; color: #4ade80; }
.diff-remove { background: #1f0707; color: #f87171; }
.diff-same { color: #333; }

/* Recommendations */
.rec-item { display: flex; align-items: flex-start; gap: 10px; padding: 8px 0; font-size: 12px; border-bottom: 1px solid #111; }
.rec-item:last-child { border-bottom: none; }
.rec-severity { width: 8px; height: 8px; border-radius: 50%; margin-top: 4px; flex-shrink: 0; }
.rec-severity.high { background: #ef4444; }
.rec-severity.med { background: #f59e0b; }
.rec-severity.low { background: #10b981; }
.rec-body { flex: 1; }
.rec-title { font-weight: 500; }
.rec-detail { font-size: 11px; color: #555; margin-top: 2px; }
.rec-impact { font-size: 10px; padding: 2px 6px; border-radius: 3px; white-space: nowrap; }
.rec-impact.high { background: #451a03; color: #fb923c; }
.rec-impact.med { background: #1c1917; color: #a8a29e; }
.rec-impact.low { background: #052e16; color: #34d399; }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <h1>Context Lens</h1>
    <div class="header-right">
      <span id="hdr-cost" style="color:#10b981;font-weight:600;"></span>
      <span id="hdr-reqs" style="color:#444;"></span>
      <select id="hdr-source-filter"><option value="">All sources</option></select>
      <button id="export-btn">Export LHAR</button>
    </div>
  </div>
  <div class="sidebar" id="sidebar"></div>
  <div class="main" id="main-panel">
    <div class="empty-main" id="empty-state">
      <div style="font-size:16px;color:#666;">No requests captured yet</div>
      <div style="font-size:12px;color:#444;">Point your LLM API calls to port 4040 to start capturing.</div>
    </div>
  </div>
</div>

<script>
(function() {
  'use strict';

  // --- State ---
  let currentData = null;
  let selectedSessionId = null;
  let selectedTurnIndex = -1; // -1 = latest
  let expandedSessions = new Set();
  let treemapMode = 'detailed';
  let timelineMode = 'all';
  let turnDetailMode = 'calls'; // 'calls' or 'diff'
  let expandedCategories = new Set();
  let sourceFilter = '';

  // --- Helpers ---
  function esc(s) { return s ? String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;') : ''; }
  function fmtK(n) { return n >= 1000 ? (n / 1000).toFixed(1) + 'K' : String(n); }
  function fmtCost(c) { return c != null ? '$' + c.toFixed(c < 0.01 ? 4 : 2) : '--'; }
  function fmtTime(iso) { return new Date(iso).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}); }

  function modelClass(m) {
    if (!m) return 'model-default';
    if (m.includes('opus')) return 'model-opus';
    if (m.includes('sonnet')) return 'model-sonnet';
    if (m.includes('haiku')) return 'model-haiku';
    if (m.includes('gpt') || m.includes('o1') || m.includes('o3') || m.includes('o4')) return 'model-gpt';
    return 'model-default';
  }

  function modelBarColor(m) {
    if (!m) return '#888';
    if (m.includes('opus')) return '#fb923c';
    if (m.includes('sonnet')) return '#60a5fa';
    if (m.includes('haiku')) return '#a78bfa';
    if (m.includes('gpt') || m.includes('o1') || m.includes('o3') || m.includes('o4')) return '#10b981';
    return '#888';
  }

  function modelBarGradient(m) {
    if (!m) return 'linear-gradient(to top, #555, #888)';
    if (m.includes('opus')) return 'linear-gradient(to top, #92400e, #fb923c)';
    if (m.includes('sonnet')) return 'linear-gradient(to top, #1e3a5f, #60a5fa)';
    if (m.includes('haiku')) return 'linear-gradient(to top, #4c1d95, #a78bfa)';
    if (m.includes('gpt') || m.includes('o1') || m.includes('o3') || m.includes('o4')) return 'linear-gradient(to top, #064e3b, #10b981)';
    return 'linear-gradient(to top, #333, #888)';
  }

  function sourceBadgeClass(src) {
    if (src === 'claude') return 'badge-claude';
    if (src === 'codex') return 'badge-codex';
    if (src === 'aider') return 'badge-aider';
    if (src === 'kimi') return 'badge-kimi';
    return 'badge-unknown';
  }

  function shortModel(m) {
    if (!m) return '?';
    // Extract the short name: "claude-opus-4-6-..." -> "opus"
    if (m.includes('opus')) return 'opus';
    if (m.includes('sonnet')) return 'sonnet';
    if (m.includes('haiku')) return 'haiku';
    if (m.includes('gpt-4o-mini')) return '4o-mini';
    if (m.includes('gpt-4o')) return '4o';
    if (m.includes('gpt-4')) return 'gpt4';
    if (m.includes('o4-mini')) return 'o4m';
    if (m.includes('o3-mini')) return 'o3m';
    if (m.includes('o3')) return 'o3';
    if (m.includes('o1')) return 'o1';
    return m.length > 10 ? m.slice(0, 8) : m;
  }

  // Category display names and colors
  var CATEGORY_META = {
    system_prompt:     { label: 'System prompt',     color: '#1e40af' },
    tool_definitions:  { label: 'Tool definitions',  color: '#be185d' },
    tool_results:      { label: 'Tool results',      color: '#065f46' },
    tool_calls:        { label: 'Tool calls',        color: '#9d174d' },
    system_injections: { label: 'System injections',  color: '#4338ca' },
    thinking:          { label: 'Thinking',           color: '#7c3aed' },
    assistant_text:    { label: 'Assistant',          color: '#b45309' },
    user_text:         { label: 'User',               color: '#059669' },
    images:            { label: 'Images',             color: '#374151' },
    cache_markers:     { label: 'Cache markers',      color: '#525252' },
    other:             { label: 'Other',              color: '#404040' },
  };

  // Simple mode groups: system, tools, messages
  var SIMPLE_GROUPS = {
    system:   ['system_prompt', 'system_injections'],
    tools:    ['tool_definitions', 'tool_calls'],
    messages: ['tool_results', 'thinking', 'assistant_text', 'user_text', 'images', 'cache_markers', 'other'],
  };
  var SIMPLE_META = {
    system:   { label: 'System',   color: '#1e40af' },
    tools:    { label: 'Tools',    color: '#be185d' },
    messages: { label: 'Messages', color: '#059669' },
  };

  // --- Data helpers ---
  function getConversations() {
    if (!currentData) return [];
    var convos = currentData.conversations || [];
    if (sourceFilter) convos = convos.filter(function(c) { return c.source === sourceFilter; });
    return convos;
  }

  function getSelectedSession() {
    if (!selectedSessionId) return null;
    var convos = getConversations();
    return convos.find(function(c) { return c.id === selectedSessionId; }) || null;
  }

  function getSessionEntries(session) {
    if (!session) return [];
    // entries are newest-first from server; reverse for chronological
    return session.entries.slice().reverse();
  }

  function getSelectedEntry(session) {
    if (!session) return null;
    var entries = getSessionEntries(session);
    if (entries.length === 0) return null;
    var idx = selectedTurnIndex >= 0 ? selectedTurnIndex : entries.length - 1;
    return entries[Math.min(idx, entries.length - 1)];
  }

  function sessionTotalCost(session) {
    return (session.entries || []).reduce(function(s, e) { return s + (e.costUsd || 0); }, 0);
  }

  function sessionTotalTokens(session) {
    return (session.entries || []).reduce(function(s, e) { return s + (e.contextInfo.totalTokens || 0); }, 0);
  }

  function allSources() {
    if (!currentData) return [];
    var set = {};
    (currentData.conversations || []).forEach(function(c) { if (c.source) set[c.source] = true; });
    return Object.keys(set).sort();
  }

  // Identify main agent entries (largest context per turn group) vs subagents
  function classifyEntries(entries) {
    // entries in chronological order
    // The "main" agent typically has the largest context window / is the one with most system tokens
    // Simple heuristic: the agent with the most total tokens in the session is main
    var agentTotals = {};
    entries.forEach(function(e) {
      var ak = e.agentKey || '_main';
      agentTotals[ak] = (agentTotals[ak] || 0) + e.contextInfo.totalTokens;
    });
    var mainAgent = null;
    var maxTok = 0;
    for (var ak in agentTotals) {
      if (agentTotals[ak] > maxTok) { maxTok = agentTotals[ak]; mainAgent = ak; }
    }
    return entries.map(function(e) {
      var ak = e.agentKey || '_main';
      return { entry: e, isMain: ak === mainAgent };
    });
  }

  // --- Render: Header ---
  function renderHeader() {
    var totalCost = 0;
    var totalReqs = 0;
    (currentData ? currentData.conversations || [] : []).forEach(function(c) {
      totalCost += sessionTotalCost(c);
      totalReqs += (c.entries || []).length;
    });
    var ungrouped = currentData ? currentData.ungrouped || [] : [];
    totalReqs += ungrouped.length;
    ungrouped.forEach(function(e) { totalCost += e.costUsd || 0; });

    document.getElementById('hdr-cost').textContent = fmtCost(totalCost);
    document.getElementById('hdr-reqs').textContent = totalReqs + ' requests';

    // Source filter dropdown
    var sel = document.getElementById('hdr-source-filter');
    var sources = allSources();
    var oldVal = sel.value;
    sel.innerHTML = '<option value="">All sources</option>';
    sources.forEach(function(s) {
      sel.innerHTML += '<option value="' + esc(s) + '"' + (s === sourceFilter ? ' selected' : '') + '>' + esc(s) + '</option>';
    });
    if (oldVal && !sources.includes(oldVal)) sel.value = '';
  }

  // --- Render: Sidebar ---
  function renderSidebar() {
    var convos = getConversations();
    var sb = document.getElementById('sidebar');

    if (convos.length === 0) {
      sb.innerHTML = '<div class="sidebar-section">Sessions</div>'
        + '<div style="padding:20px 12px;color:#444;font-size:12px;">No sessions yet</div>';
      return;
    }

    var html = '<div class="sidebar-section">Sessions</div>';

    // Aggregate stats
    var mainCalls = 0, subCalls = 0, totalCost = 0;

    convos.forEach(function(c) {
      var isActive = c.id === selectedSessionId;
      var entries = getSessionEntries(c);
      var classified = classifyEntries(entries);
      var mainCount = classified.filter(function(x) { return x.isMain; }).length;
      var subCount = classified.filter(function(x) { return !x.isMain; }).length;
      mainCalls += mainCount;
      subCalls += subCount;
      var cost = sessionTotalCost(c);
      totalCost += cost;
      var latestEntry = entries[entries.length - 1];
      var model = latestEntry ? latestEntry.contextInfo.model : 'unknown';
      var isExpanded = isActive && expandedSessions.has(c.id);

      // Session item
      html += '<div class="session-item' + (isActive ? ' active' : '') + '" data-session="' + esc(c.id) + '">';
      html += '<div class="session-head">';
      html += '<span class="dot ' + (isActive ? 'dot-live' : 'dot-done') + '"></span>';
      html += '<span class="badge ' + sourceBadgeClass(c.source) + '">' + esc(c.source || '?') + '</span>';
      html += '<span style="font-size:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">' + esc(model) + '</span>';
      html += '</div>';
      html += '<div class="session-meta"><span>' + entries.length + ' turns</span><span>' + fmtK(sessionTotalTokens(c)) + ' tok</span><span style="color:#10b981;">' + fmtCost(cost) + '</span></div>';
      if (c.workingDirectory) html += '<div class="working-dir">' + esc(c.workingDirectory) + '</div>';
      html += '</div>';

      // Turn group (expandable)
      html += '<div class="turn-group' + (isExpanded ? ' expanded' : '') + '" data-turns="' + esc(c.id) + '">';

      // Show main-agent turns with sub-agent dots
      var mainEntries = classified.filter(function(x) { return x.isMain; });
      var turnNum = 0;

      // Group entries into turns: each main entry is a turn, subagent entries between them are listed as dots
      var lastMainIdx = -1;
      classified.forEach(function(item, idx) {
        if (!item.isMain) return;
        turnNum++;
        // Sub-agent dots between last main and this one
        var subsBefore = [];
        for (var j = lastMainIdx + 1; j < idx; j++) {
          if (!classified[j].isMain) subsBefore.push(classified[j]);
        }

        var e = item.entry;
        var turnActive = isActive && (selectedTurnIndex === -1 ? turnNum === mainEntries.length : selectedTurnIndex === idx);
        var label = esc(c.label || '').slice(0, 30);
        // Try to use agentLabel
        var desc = esc(e.agentLabel || '').slice(0, 30) || 'Turn ' + turnNum;

        html += '<div class="tg-item' + (turnActive ? ' active' : '') + '" data-session="' + esc(c.id) + '" data-turn="' + idx + '">';
        html += '<span class="tg-num">' + turnNum + '</span>';
        html += '<span class="tg-model ' + modelClass(e.contextInfo.model) + '" style="background:#1e1e1e;padding:1px 4px;border-radius:2px;font-size:9px;">' + esc(shortModel(e.contextInfo.model)) + '</span>';
        html += '<span class="tg-desc">' + desc + '</span>';
        html += '<span class="tg-tokens">' + fmtK(e.contextInfo.totalTokens) + '</span>';
        html += '</div>';

        // Sub-agent dots after this turn
        var subsAfter = [];
        for (var k = idx + 1; k < classified.length; k++) {
          if (classified[k].isMain) break;
          subsAfter.push(classified[k]);
        }
        if (subsAfter.length > 0) {
          html += '<div class="sub-dots">';
          subsAfter.forEach(function() { html += '<span class="sub-dot"></span>'; });
          var subModel = shortModel(subsAfter[0].entry.contextInfo.model);
          html += ' ' + esc(subModel) + ' x' + subsAfter.length;
          html += '</div>';
        }

        lastMainIdx = idx;
      });

      html += '</div>'; // turn-group
    });

    // Footer
    html += '<div class="sidebar-footer">';
    html += '<div><span>Main calls</span><span style="color:#fb923c;">' + mainCalls + '</span></div>';
    html += '<div><span>Subagent calls</span><span style="color:#a78bfa;">' + subCalls + '</span></div>';
    html += '<div><span>Total cost</span><span style="color:#10b981;">' + fmtCost(totalCost) + '</span></div>';
    html += '</div>';

    sb.innerHTML = html;

    // Attach click handlers
    sb.querySelectorAll('.session-item').forEach(function(el) {
      el.addEventListener('click', function() {
        var sid = el.getAttribute('data-session');
        if (selectedSessionId === sid) {
          // Toggle turn list expansion
          if (expandedSessions.has(sid)) expandedSessions.delete(sid);
          else expandedSessions.add(sid);
        } else {
          selectedSessionId = sid;
          selectedTurnIndex = -1;
          expandedSessions.add(sid);
        }
        renderSidebar();
        renderMain();
      });
    });

    sb.querySelectorAll('.tg-item').forEach(function(el) {
      el.addEventListener('click', function(ev) {
        ev.stopPropagation();
        var sid = el.getAttribute('data-session');
        var turn = parseInt(el.getAttribute('data-turn'), 10);
        selectedSessionId = sid;
        selectedTurnIndex = turn;
        renderSidebar();
        renderMain();
      });
    });
  }

  // --- Render: Main Panel ---
  function renderMain() {
    var main = document.getElementById('main-panel');
    var session = getSelectedSession();

    if (!session) {
      // Check if we have any data at all
      var convos = getConversations();
      if (convos.length === 0) {
        main.innerHTML = '<div class="empty-main"><div style="font-size:16px;color:#666;">No requests captured yet</div>'
          + '<div style="font-size:12px;color:#444;">Point your LLM API calls to port 4040 to start capturing.</div></div>';
      } else {
        main.innerHTML = '<div class="empty-main"><div style="font-size:14px;color:#555;">Select a session from the sidebar</div></div>';
      }
      return;
    }

    var entries = getSessionEntries(session);
    var classified = classifyEntries(entries);
    var entry = getSelectedEntry(session);
    if (!entry) return;

    var ci = entry.contextInfo;
    var utilPct = entry.contextLimit > 0 ? Math.round((ci.totalTokens / entry.contextLimit) * 100) : 0;
    var sessionCost = sessionTotalCost(session);
    var msgCount = ci.messages ? ci.messages.length : 0;
    // Count tool calls in the composition
    var toolCallEntry = (entry.composition || []).find(function(c) { return c.category === 'tool_calls'; });
    var toolCallCount = toolCallEntry ? toolCallEntry.count : 0;

    var html = '';

    // --- Stats row ---
    var utilColor = utilPct > 80 ? 'red' : utilPct > 60 ? 'amber' : 'blue';
    html += '<div class="stats-row">';
    html += '<div class="panel"><div class="panel-body"><div class="stat-card"><div class="stat-val ' + utilColor + '">' + utilPct + '%</div><div class="stat-lbl">Context used (' + fmtK(ci.totalTokens) + ' / ' + fmtK(entry.contextLimit) + ')</div></div></div></div>';
    html += '<div class="panel"><div class="panel-body"><div class="stat-card"><div class="stat-val green">' + fmtCost(sessionCost) + '</div><div class="stat-lbl">Session cost</div></div></div></div>';
    html += '<div class="panel"><div class="panel-body"><div class="stat-card"><div class="stat-val white">' + msgCount + '</div><div class="stat-lbl">Messages in context</div></div></div></div>';
    html += '<div class="panel"><div class="panel-body"><div class="stat-card"><div class="stat-val amber">' + toolCallCount + '</div><div class="stat-lbl">Tool calls this turn</div></div></div></div>';
    html += '</div>';

    // --- Treemap ---
    html += renderTreemap(entry);

    // --- Agent breakdown ---
    html += renderAgentBreakdown(session, classified);

    // --- Timeline ---
    html += renderTimeline(entries, classified);

    // --- Turn Detail ---
    html += renderTurnDetail(entry, entries, classified);

    // --- Recommendations ---
    html += renderRecommendations(entry, entries, classified);

    main.innerHTML = html;
    attachMainHandlers();
  }

  // --- Treemap ---
  function renderTreemap(entry) {
    var composition = entry.composition || [];
    if (composition.length === 0) return '';

    var totalTok = composition.reduce(function(s, c) { return s + c.tokens; }, 0);
    var turnLabel = '';
    // Find turn number
    var session = getSelectedSession();
    if (session) {
      var entries = getSessionEntries(session);
      var classified = classifyEntries(entries);
      var mainEntries = classified.filter(function(x) { return x.isMain; });
      var turnIdx = -1;
      for (var i = 0; i < entries.length; i++) {
        if (entries[i].id === entry.id) { turnIdx = i; break; }
      }
      // Find which main turn this is
      var mainNum = 0;
      for (var j = 0; j < classified.length; j++) {
        if (classified[j].isMain) mainNum++;
        if (classified[j].entry.id === entry.id) break;
      }
      turnLabel = ' -- Turn ' + mainNum;
    }

    var html = '<div class="panel">';
    html += '<div class="panel-header">Context Composition' + esc(turnLabel) + ' (' + fmtK(totalTok) + ' tok)';
    html += '<div class="toggle-group">';
    html += '<div class="toggle-btn' + (treemapMode === 'detailed' ? ' active' : '') + '" data-treemap="detailed">Detailed</div>';
    html += '<div class="toggle-btn' + (treemapMode === 'simple' ? ' active' : '') + '" data-treemap="simple">Simple</div>';
    html += '</div></div>';
    html += '<div class="panel-body">';

    if (treemapMode === 'detailed') {
      html += '<div class="treemap">';
      composition.forEach(function(c) {
        var meta = CATEGORY_META[c.category] || { label: c.category, color: '#404040' };
        var pct = totalTok > 0 ? Math.round(c.tokens / totalTok * 100) : 0;
        // Only show label if segment is wide enough (> 3%)
        var labelHtml = pct >= 3 ? esc(meta.label) + '<span>' + fmtK(c.tokens) + ' (' + pct + '%)</span>' : '';
        html += '<div class="treemap-block tm-' + esc(c.category) + '" style="flex:' + c.tokens + ';" title="' + esc(meta.label) + ': ' + c.tokens.toLocaleString() + ' tokens (' + pct + '%)">' + labelHtml + '</div>';
      });
      html += '</div>';

      // Legend
      html += '<div class="treemap-legend">';
      composition.forEach(function(c) {
        var meta = CATEGORY_META[c.category] || { label: c.category, color: '#404040' };
        html += '<div class="treemap-legend-item"><div class="treemap-legend-dot" style="background:' + meta.color + ';"></div>' + esc(meta.label) + '</div>';
      });
      html += '</div>';
    } else {
      // Simple mode: group into system/tools/messages
      var groups = {};
      for (var gk in SIMPLE_GROUPS) {
        groups[gk] = 0;
        SIMPLE_GROUPS[gk].forEach(function(cat) {
          var found = composition.find(function(c) { return c.category === cat; });
          if (found) groups[gk] += found.tokens;
        });
      }

      html += '<div class="treemap">';
      for (var gk2 in groups) {
        if (groups[gk2] === 0) continue;
        var meta2 = SIMPLE_META[gk2];
        var pct2 = totalTok > 0 ? Math.round(groups[gk2] / totalTok * 100) : 0;
        html += '<div class="treemap-block" style="flex:' + groups[gk2] + ';background:' + meta2.color + ';">'
          + esc(meta2.label) + '<span>' + fmtK(groups[gk2]) + ' (' + pct2 + '%)</span></div>';
      }
      html += '</div>';

      html += '<div class="treemap-legend">';
      for (var gk3 in SIMPLE_META) {
        if (!groups[gk3]) continue;
        html += '<div class="treemap-legend-item"><div class="treemap-legend-dot" style="background:' + SIMPLE_META[gk3].color + ';"></div>' + esc(SIMPLE_META[gk3].label) + '</div>';
      }
      html += '</div>';
    }

    html += '</div></div>';
    return html;
  }

  // --- Agent Breakdown ---
  function renderAgentBreakdown(session, classified) {
    // Group by agentKey
    var agents = {};
    var totalTok = 0;
    classified.forEach(function(item) {
      var ak = item.entry.agentKey || '_main';
      if (!agents[ak]) {
        agents[ak] = { key: ak, label: item.entry.agentLabel || 'Main', model: item.entry.contextInfo.model, tokens: 0, cost: 0, count: 0, isMain: item.isMain };
      }
      agents[ak].tokens += item.entry.contextInfo.totalTokens;
      agents[ak].cost += item.entry.costUsd || 0;
      agents[ak].count += 1;
      totalTok += item.entry.contextInfo.totalTokens;
    });

    var agentList = Object.values(agents);
    agentList.sort(function(a, b) { return b.tokens - a.tokens; });

    var html = '<div class="panel">';
    html += '<div class="panel-header">Agent Breakdown</div>';
    html += '<div class="panel-body">';

    agentList.forEach(function(ag) {
      var pct = totalTok > 0 ? Math.round(ag.tokens / totalTok * 100) : 0;
      var role = ag.isMain ? 'main' : 'sub';
      var color = modelBarColor(ag.model);
      html += '<div class="agent-row">';
      html += '<span class="agent-lbl">' + esc(shortModel(ag.model)) + ' (' + role + ')</span>';
      html += '<div class="agent-bar-wrap"><div class="agent-bar" style="width:' + pct + '%;background:' + color + ';"></div></div>';
      html += '<span class="agent-val">' + fmtK(ag.tokens) + ' tok / ' + fmtCost(ag.cost) + '</span>';
      html += '</div>';
    });

    // Summary line
    var subPct = classified.length > 0
      ? Math.round(classified.filter(function(x) { return !x.isMain; }).length / classified.length * 100)
      : 0;
    if (subPct > 0) {
      var subTokPct = 0;
      var subTok = classified.filter(function(x) { return !x.isMain; }).reduce(function(s, x) { return s + x.entry.contextInfo.totalTokens; }, 0);
      if (totalTok > 0) subTokPct = Math.round(subTok / totalTok * 100);
      html += '<div style="margin-top:8px;font-size:11px;color:#444;">'
        + subPct + '% of calls are subagents, but only ' + subTokPct + '% of tokens.</div>';
    }

    html += '</div></div>';
    return html;
  }

  // --- Timeline ---
  function renderTimeline(entries, classified) {
    if (entries.length === 0) return '';

    var filtered = classified;
    if (timelineMode === 'main') {
      filtered = classified.filter(function(x) { return x.isMain; });
    }

    var maxTok = 0;
    filtered.forEach(function(item) {
      var val = timelineMode === 'cost' ? (item.entry.costUsd || 0) * 100000 : item.entry.contextInfo.totalTokens;
      if (val > maxTok) maxTok = val;
    });

    var selectedEntry = getSelectedEntry(getSelectedSession());

    var html = '<div class="panel">';
    html += '<div class="panel-header">Timeline';
    html += '<div class="toggle-group">';
    html += '<div class="toggle-btn' + (timelineMode === 'all' ? ' active' : '') + '" data-timeline="all">All calls</div>';
    html += '<div class="toggle-btn' + (timelineMode === 'main' ? ' active' : '') + '" data-timeline="main">Main only</div>';
    html += '<div class="toggle-btn' + (timelineMode === 'cost' ? ' active' : '') + '" data-timeline="cost">Cost</div>';
    html += '</div></div>';
    html += '<div class="panel-body">';
    html += '<div class="timeline-chart">';

    filtered.forEach(function(item, i) {
      var val = timelineMode === 'cost' ? (item.entry.costUsd || 0) * 100000 : item.entry.contextInfo.totalTokens;
      var pct = maxTok > 0 ? Math.max(2, Math.round(val / maxTok * 100)) : 2;
      var isActive = selectedEntry && item.entry.id === selectedEntry.id;
      var model = item.entry.contextInfo.model;
      // Find original index in entries array for turn selection
      var origIdx = entries.indexOf(item.entry);
      html += '<div class="tl-bar' + (isActive ? ' active' : '') + '" style="height:' + pct + '%;background:' + modelBarGradient(model) + ';" data-tl-turn="' + origIdx + '" title="' + esc(shortModel(model)) + ': ' + fmtK(item.entry.contextInfo.totalTokens) + ' tok"></div>';
    });

    html += '</div>';

    // Legend: collect unique models
    var seenModels = {};
    filtered.forEach(function(item) {
      var m = item.entry.contextInfo.model;
      var sm = shortModel(m);
      if (!seenModels[sm]) seenModels[sm] = { model: m, isMain: item.isMain };
    });

    html += '<div class="tl-legend">';
    for (var sm in seenModels) {
      var info = seenModels[sm];
      var role = info.isMain ? 'Main' : 'Subagent';
      html += '<div class="tl-legend-item"><span class="tl-legend-dot" style="background:' + modelBarColor(info.model) + ';"></span>' + role + ' (' + esc(sm) + ')</div>';
    }
    html += '</div>';

    html += '</div></div>';
    return html;
  }

  // --- Turn Detail ---
  function renderTurnDetail(entry, entries, classified) {
    var idx = entries.indexOf(entry);
    // Find the turn group: the main entry at or before idx, plus sub-entries around it
    var turnGroup = [];
    var mainIdx = idx;
    // Walk back to find the main entry that starts this turn group
    for (var i = idx; i >= 0; i--) {
      if (classified[i].isMain) { mainIdx = i; break; }
    }
    // Collect: the main entry + all sub-entries until next main
    for (var j = mainIdx; j < classified.length; j++) {
      if (j > mainIdx && classified[j].isMain) break;
      turnGroup.push(classified[j]);
    }

    // Compute turn number
    var turnNum = 0;
    for (var k = 0; k <= mainIdx; k++) {
      if (classified[k].isMain) turnNum++;
    }

    var html = '<div class="panel">';
    html += '<div class="panel-header">Turn ' + turnNum + ' -- Detail';
    html += '<div class="toggle-group">';
    html += '<div class="toggle-btn' + (turnDetailMode === 'calls' ? ' active' : '') + '" data-detail="calls">Calls</div>';
    html += '<div class="toggle-btn' + (turnDetailMode === 'diff' ? ' active' : '') + '" data-detail="diff">Diff</div>';
    html += '</div></div>';
    html += '<div class="panel-body">';

    if (turnDetailMode === 'calls') {
      // API calls list
      html += '<div class="turn-detail-header">' + turnGroup.length + ' API call' + (turnGroup.length !== 1 ? 's' : '') + ' in turn group</div>';
      turnGroup.forEach(function(item) {
        var e = item.entry;
        var isMain = item.isMain;
        var sm = shortModel(e.contextInfo.model);
        var desc = esc((e.agentLabel || '').slice(0, 60)) || (isMain ? 'Main call' : 'Subagent call');
        html += '<div class="call-row' + (isMain ? ' main-call' : '') + '">';
        html += '<span class="call-model ' + modelClass(e.contextInfo.model) + '" style="background:#1e1e1e;">' + esc(sm) + '</span>';
        html += '<span class="call-desc' + (isMain ? ' main' : '') + '">' + desc + '</span>';
        html += '<span class="call-tok">' + fmtK(e.contextInfo.totalTokens) + ' tok</span>';
        html += '<span class="call-cost">' + fmtCost(e.costUsd) + '</span>';
        html += '</div>';
      });

      // Message categories breakdown for the selected entry
      html += renderMessageCategories(entry);
    } else {
      // Diff view
      html += renderContextDiff(entry, entries, classified, turnNum);
    }

    html += '</div></div>';
    return html;
  }

  // --- Message Categories ---
  function renderMessageCategories(entry) {
    var ci = entry.contextInfo;
    var msgs = ci.messages || [];
    if (msgs.length === 0) return '';

    var msgTokens = msgs.reduce(function(s, m) { return s + (m.tokens || 0); }, 0);

    var html = '<div class="msg-section">';
    html += '<div class="msg-section-title"><span>Main agent context -- ' + msgs.length + ' messages</span><span>' + fmtK(msgTokens) + ' msg tokens</span></div>';

    // Group messages by category
    var categories = {};
    var catOrder = ['tool_results', 'system_injections', 'tool_calls', 'thinking', 'assistant_text', 'user_text'];

    msgs.forEach(function(msg, i) {
      var cat = classifyMessageRole(msg);
      if (!categories[cat]) categories[cat] = { items: [], tokens: 0 };
      categories[cat].items.push({ msg: msg, idx: i });
      categories[cat].tokens += msg.tokens || 0;
    });

    // Add categories not in catOrder
    for (var cat in categories) {
      if (catOrder.indexOf(cat) === -1) catOrder.push(cat);
    }

    catOrder.forEach(function(cat) {
      var data = categories[cat];
      if (!data) return;
      var meta = CATEGORY_META[cat] || { label: cat, color: '#404040' };
      var pct = msgTokens > 0 ? Math.round(data.tokens / msgTokens * 100) : 0;
      var catId = 'msgcat-' + cat;
      var isExpanded = expandedCategories.has(catId);
      var arrow = isExpanded ? '\u25BE' : '\u25B8';

      html += '<div class="msg-category">';
      html += '<div class="msg-cat-header" data-cat="' + catId + '">';
      html += '<span style="color:#666;">' + arrow + '</span>';
      html += '<span class="msg-cat-dot" style="background:' + meta.color + ';"></span>';
      html += '<span class="msg-cat-name" style="color:' + catTextColor(cat) + ';">' + esc(meta.label) + '</span>';
      html += '<span class="msg-cat-stats">' + fmtK(data.tokens) + ' tok (' + pct + '%)</span>';
      html += '<div class="msg-cat-bar-wrap"><div class="msg-cat-bar" style="width:' + pct + '%;background:' + meta.color + ';"></div></div>';
      html += '</div>';

      // Items
      html += '<div class="msg-items' + (isExpanded ? ' expanded' : '') + '" id="' + catId + '">';
      data.items.forEach(function(item) {
        var msg = item.msg;
        var preview = extractPreview(msg);
        var isLarge = (msg.tokens || 0) > 1000;
        html += '<div class="msg-line">';
        html += '<span class="msg-line-icon">' + catIcon(cat) + '</span>';
        html += '<span class="msg-line-text">' + esc(preview) + '</span>';
        html += '<span class="msg-line-tok' + (isLarge ? ' large' : '') + '">' + fmtK(msg.tokens || 0) + ' tok</span>';
        html += '</div>';
      });
      html += '</div>';
      html += '</div>';
    });

    html += '</div>';
    return html;
  }

  function classifyMessageRole(msg) {
    var role = msg.role || 'user';
    var content = msg.content || '';
    var blocks = msg.contentBlocks;

    // Check content blocks first
    if (blocks && Array.isArray(blocks)) {
      var hasToolUse = blocks.some(function(b) { return b.type === 'tool_use'; });
      var hasToolResult = blocks.some(function(b) { return b.type === 'tool_result'; });
      var hasThinking = blocks.some(function(b) { return b.type === 'thinking'; });
      if (hasToolResult) return 'tool_results';
      if (hasToolUse) return 'tool_calls';
      if (hasThinking) return 'thinking';
    }

    if (typeof content === 'string' && content.includes('<system-reminder>')) return 'system_injections';
    if (role === 'assistant') return 'assistant_text';
    if (role === 'user') return 'user_text';
    return 'other';
  }

  function extractPreview(msg) {
    var content = msg.content || '';
    var blocks = msg.contentBlocks;

    if (blocks && Array.isArray(blocks)) {
      // Find a meaningful block to preview
      for (var i = 0; i < blocks.length; i++) {
        var b = blocks[i];
        if (b.type === 'tool_use') return esc(b.name || 'tool') + '(' + (b.input ? JSON.stringify(b.input).slice(0, 60) : '') + ')';
        if (b.type === 'tool_result') {
          var rc = typeof b.content === 'string' ? b.content : JSON.stringify(b.content || '');
          return rc.slice(0, 80);
        }
        if (b.type === 'thinking') return (b.thinking || b.text || '').slice(0, 80);
        if (b.type === 'text' || b.type === 'input_text') return (b.text || '').slice(0, 80);
      }
    }

    // Try to parse JSON content (e.g. stringified blocks)
    if (content.charAt(0) === '[') {
      try {
        var parsed = JSON.parse(content);
        if (Array.isArray(parsed) && parsed[0]) {
          var first = parsed[0];
          if (first.type === 'tool_use') return (first.name || 'tool') + '(...)';
          if (first.type === 'tool_result') return String(first.content || '').slice(0, 80);
          if (first.text) return first.text.slice(0, 80);
        }
      } catch(e) {}
    }

    return content.slice(0, 80);
  }

  function catTextColor(cat) {
    var colors = {
      tool_results: '#10b981', system_injections: '#818cf8', tool_calls: '#f472b6',
      thinking: '#a78bfa', assistant_text: '#f59e0b', user_text: '#10b981',
      images: '#9ca3af', other: '#9ca3af',
    };
    return colors[cat] || '#888';
  }

  function catIcon(cat) {
    // CSS-only indicators per the constraint (no emoji)
    var icons = {
      tool_results: '\u25A0', // filled square
      system_injections: '\u25C6', // diamond
      tool_calls: '\u25B6', // right triangle
      thinking: '\u25CB', // circle
      assistant_text: '\u25B7', // triangle outline
      user_text: '\u25CF', // filled circle
    };
    return icons[cat] || '\u25AA';
  }

  // --- Context Diff ---
  function renderContextDiff(entry, entries, classified, turnNum) {
    var idx = entries.indexOf(entry);
    // Find previous main entry
    var prevEntry = null;
    for (var i = idx - 1; i >= 0; i--) {
      if (classified[i].isMain) { prevEntry = entries[i]; break; }
    }

    if (!prevEntry) {
      return '<div style="color:#444;font-size:12px;">First turn -- no previous context to diff against.</div>';
    }

    var prevComp = prevEntry.composition || [];
    var currComp = entry.composition || [];
    var prevTotal = prevComp.reduce(function(s, c) { return s + c.tokens; }, 0);
    var currTotal = currComp.reduce(function(s, c) { return s + c.tokens; }, 0);
    var delta = currTotal - prevTotal;
    var deltaSign = delta >= 0 ? '+' : '';

    var html = '<div class="diff-header">';
    html += '<span>Turn ' + (turnNum - 1) + ' \u2192 Turn ' + turnNum + '</span>';
    html += '<span>' + deltaSign + fmtK(delta) + ' tokens</span>';
    html += '</div>';

    // Build a merged view of categories
    var allCats = {};
    prevComp.forEach(function(c) { allCats[c.category] = true; });
    currComp.forEach(function(c) { allCats[c.category] = true; });

    for (var cat in allCats) {
      var prev = prevComp.find(function(c) { return c.category === cat; });
      var curr = currComp.find(function(c) { return c.category === cat; });
      var prevTok = prev ? prev.tokens : 0;
      var currTok = curr ? curr.tokens : 0;
      var d = currTok - prevTok;
      var meta = CATEGORY_META[cat] || { label: cat };

      if (d === 0) {
        html += '<div class="diff-line diff-same">  ' + esc(meta.label) + ': ' + fmtK(currTok) + ' tok (unchanged)</div>';
      } else if (prevTok === 0) {
        html += '<div class="diff-line diff-add">+ ' + esc(meta.label) + ': ' + fmtK(currTok) + ' tok (new)</div>';
      } else if (currTok === 0) {
        html += '<div class="diff-line diff-remove">- ' + esc(meta.label) + ': ' + fmtK(prevTok) + ' tok (removed)</div>';
      } else if (d > 0) {
        html += '<div class="diff-line diff-add">+ ' + esc(meta.label) + ': ' + fmtK(prevTok) + ' \u2192 ' + fmtK(currTok) + ' tok (+' + fmtK(d) + ')</div>';
      } else {
        html += '<div class="diff-line diff-remove">- ' + esc(meta.label) + ': ' + fmtK(prevTok) + ' \u2192 ' + fmtK(currTok) + ' tok (' + fmtK(d) + ')</div>';
      }
    }

    return html;
  }

  // --- Recommendations ---
  function renderRecommendations(entry, entries, classified) {
    var recs = [];
    var ci = entry.contextInfo;
    var comp = entry.composition || [];
    var totalTok = comp.reduce(function(s, c) { return s + c.tokens; }, 0);

    // 1. Large single tool result
    var toolResults = comp.find(function(c) { return c.category === 'tool_results'; });
    if (toolResults && totalTok > 0 && toolResults.pct > 25) {
      // Check individual messages for oversized tool results
      var largestResult = 0;
      (ci.messages || []).forEach(function(m) {
        if (m.tokens > largestResult && classifyMessageRole(m) === 'tool_results') {
          largestResult = m.tokens;
        }
      });
      if (largestResult > 2000) {
        recs.push({
          severity: 'high',
          title: 'Large tool result: ' + fmtK(largestResult) + ' tokens (' + Math.round(largestResult / totalTok * 100) + '% of context)',
          detail: 'Single tool result consuming disproportionate context. Consider truncating large outputs or using summary flags.',
          impact: fmtK(largestResult) + ' tok',
        });
      }
    }

    // 2. Tool definitions overhead
    var toolDefs = comp.find(function(c) { return c.category === 'tool_definitions'; });
    if (toolDefs && toolDefs.pct > 30) {
      // Count unique tool calls in the session
      var usedTools = {};
      entries.forEach(function(e) {
        (e.contextInfo.messages || []).forEach(function(m) {
          if (m.contentBlocks) {
            m.contentBlocks.forEach(function(b) {
              if (b.type === 'tool_use' && b.name) usedTools[b.name] = true;
            });
          }
        });
      });
      var usedCount = Object.keys(usedTools).length;
      var totalTools = ci.tools ? ci.tools.length : 0;
      if (totalTools > usedCount + 3) {
        recs.push({
          severity: 'high',
          title: 'Tool definitions are ' + toolDefs.pct + '% of context but only ' + usedCount + ' unique tools used',
          detail: fmtK(toolDefs.tokens) + ' tokens for ' + totalTools + ' tool definitions. ' + (totalTools - usedCount) + ' tools loaded but unused.',
          impact: '~' + fmtK(Math.round(toolDefs.tokens * (totalTools - usedCount) / totalTools)) + ' tok',
        });
      }
    }

    // 3. Tool results domination
    if (toolResults && toolResults.pct > 60) {
      var userText = comp.find(function(c) { return c.category === 'user_text'; });
      var userPct = userText ? userText.pct : 0;
      recs.push({
        severity: 'med',
        title: 'Tool results are ' + toolResults.pct + '% of the messages section',
        detail: 'Your conversation is ' + userPct + '% user text, ' + toolResults.pct + '% tool output. Consider summarizing older tool results.',
        impact: 'Structural',
      });
    }

    // 4. Context utilization check
    var utilPct = entry.contextLimit > 0 ? Math.round(ci.totalTokens / entry.contextLimit * 100) : 0;
    if (utilPct > 80) {
      recs.push({
        severity: 'high',
        title: 'Context utilization critical at ' + utilPct + '%',
        detail: fmtK(ci.totalTokens) + ' of ' + fmtK(entry.contextLimit) + ' tokens used. Risk of context overflow soon.',
        impact: 'Critical',
      });
    } else if (utilPct > 60) {
      recs.push({
        severity: 'med',
        title: 'Context utilization high at ' + utilPct + '%',
        detail: fmtK(ci.totalTokens) + ' of ' + fmtK(entry.contextLimit) + ' tokens used.',
        impact: 'Monitor',
      });
    } else {
      recs.push({
        severity: 'low',
        title: 'Context utilization healthy at ' + utilPct + '%',
        detail: fmtK(ci.totalTokens) + ' of ' + fmtK(entry.contextLimit) + ' tokens used. Well within safe range.',
        impact: 'OK',
      });
    }

    // 5. Compaction detected
    var idx = entries.indexOf(entry);
    if (idx > 0) {
      var prevIdx = -1;
      for (var i = idx - 1; i >= 0; i--) {
        if (classified[i].isMain) { prevIdx = i; break; }
      }
      if (prevIdx >= 0) {
        var prevTok = entries[prevIdx].contextInfo.totalTokens;
        if (ci.totalTokens < prevTok * 0.7) {
          recs.push({
            severity: 'med',
            title: 'Context compaction detected',
            detail: 'Tokens dropped from ' + fmtK(prevTok) + ' to ' + fmtK(ci.totalTokens) + '. The tool may have summarized or truncated earlier context.',
            impact: '-' + fmtK(prevTok - ci.totalTokens) + ' tok',
          });
        }
      }
    }

    // 6. System injections overhead
    var sysInj = comp.find(function(c) { return c.category === 'system_injections'; });
    if (sysInj && sysInj.pct > 5) {
      recs.push({
        severity: 'med',
        title: 'System injections are ' + sysInj.pct + '% of context',
        detail: fmtK(sysInj.tokens) + ' tokens of system-reminder blocks injected into messages.',
        impact: fmtK(sysInj.tokens) + ' tok',
      });
    }

    if (recs.length === 0) return '';

    var html = '<div class="panel">';
    html += '<div class="panel-header">Recommendations <span style="font-size:10px;color:#555;">' + recs.length + ' finding' + (recs.length !== 1 ? 's' : '') + '</span></div>';
    html += '<div class="panel-body">';

    recs.forEach(function(r) {
      html += '<div class="rec-item">';
      html += '<span class="rec-severity ' + r.severity + '"></span>';
      html += '<div class="rec-body">';
      html += '<div class="rec-title">' + esc(r.title) + '</div>';
      html += '<div class="rec-detail">' + esc(r.detail) + '</div>';
      html += '</div>';
      html += '<span class="rec-impact ' + r.severity + '">' + esc(r.impact) + '</span>';
      html += '</div>';
    });

    html += '</div></div>';
    return html;
  }

  // --- Event handlers for main panel ---
  function attachMainHandlers() {
    // Treemap toggle
    document.querySelectorAll('[data-treemap]').forEach(function(el) {
      el.addEventListener('click', function() {
        treemapMode = el.getAttribute('data-treemap');
        renderMain();
      });
    });

    // Timeline toggle
    document.querySelectorAll('[data-timeline]').forEach(function(el) {
      el.addEventListener('click', function() {
        timelineMode = el.getAttribute('data-timeline');
        renderMain();
      });
    });

    // Turn detail toggle
    document.querySelectorAll('[data-detail]').forEach(function(el) {
      el.addEventListener('click', function() {
        turnDetailMode = el.getAttribute('data-detail');
        renderMain();
      });
    });

    // Message category expand/collapse
    document.querySelectorAll('[data-cat]').forEach(function(el) {
      el.addEventListener('click', function() {
        var catId = el.getAttribute('data-cat');
        if (expandedCategories.has(catId)) expandedCategories.delete(catId);
        else expandedCategories.add(catId);
        renderMain();
      });
    });

    // Timeline bar click -> select turn
    document.querySelectorAll('[data-tl-turn]').forEach(function(el) {
      el.addEventListener('click', function() {
        var idx = parseInt(el.getAttribute('data-tl-turn'), 10);
        if (!isNaN(idx)) {
          selectedTurnIndex = idx;
          renderSidebar();
          renderMain();
        }
      });
    });
  }

  // --- Source filter ---
  document.getElementById('hdr-source-filter').addEventListener('change', function() {
    sourceFilter = this.value;
    // If current session is filtered out, deselect
    if (selectedSessionId) {
      var session = getSelectedSession();
      if (!session) {
        selectedSessionId = null;
        selectedTurnIndex = -1;
      }
    }
    renderSidebar();
    renderMain();
  });

  // --- Export ---
  document.getElementById('export-btn').addEventListener('click', function() {
    var url = '/api/export/lhar.json';
    if (selectedSessionId) url += '?conversation=' + encodeURIComponent(selectedSessionId);
    fetch(url).then(function(r) { return r.blob(); }).then(function(blob) {
      var a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'context-lens-export.lhar.json';
      a.click();
      URL.revokeObjectURL(a.href);
    });
  });

  // --- Polling ---
  function fetchAndRender() {
    fetch('/api/requests').then(function(r) { return r.json(); }).then(function(data) {
      var changed = JSON.stringify(data) !== JSON.stringify(currentData);
      currentData = data;

      if (changed) {
        // Auto-select first session if none selected
        if (!selectedSessionId) {
          var convos = getConversations();
          if (convos.length > 0) {
            selectedSessionId = convos[0].id;
            selectedTurnIndex = -1;
            expandedSessions.add(convos[0].id);
          }
        }
        renderHeader();
        renderSidebar();
        renderMain();
      }
    }).catch(function(err) {
      console.error('Fetch error:', err);
    });
  }

  fetchAndRender();
  setInterval(fetchAndRender, 2000);
})();
</script>
</body>
</html>
